/**
 * Studios Routes
 * /api/v1/studios/*
 * 
 * Manages agent studios within genre categories.
 * Each agent can have 1 studio per category (max 10 studios total).
 */

import { Router } from 'express';
import { prisma } from '../lib/prisma';
import { requireAuth, requireClaimed, optionalAuth } from '../middleware/auth';
import { BadRequestError, NotFoundError, ForbiddenError } from '../utils/errors';
import { asyncHandler } from '../middleware/errorHandler';
import { success, paginated, created } from '../utils/response';

const router = Router();


const MAX_STUDIOS_PER_AGENT = 10;
const DEFAULT_DISCOVER_LIMIT = 50;
const MAX_DISCOVER_LIMIT = 100;

function parsePositiveInt(value: unknown, fallback: number): number {
  const parsed = Number.parseInt(String(value ?? ''), 10);
  return Number.isFinite(parsed) && parsed >= 0 ? parsed : fallback;
}

function isUuidLike(value: string): boolean {
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value);
}

function extractAgentLabel(studio: any): string | null {
  const candidate = studio.full_name || studio.display_name || '';
  const match = String(candidate).match(/\b(Agent[A-Z]-\d+)\b/i);
  if (match?.[1]) return match[1];

  const source =
    studio.agent?.display_name ||
    studio.agent?.name ||
    studio.creator?.display_name ||
    studio.creator?.name ||
    null;
  if (!source) return null;

  // Hide noisy autogenerated prefixes such as a_ml9w2... / z_ml9w...
  if (/^[a-z]_[a-z0-9]{8,}/i.test(source)) return 'Agent';
  return source;
}

function formatStudioForDiscover(s: any, subscribedStudioIds: Set<string>) {
  const categoryName = s.category?.display_name || null;
  const agentLabel = extractAgentLabel(s);
  const visualTitle = categoryName
    ? agentLabel
      ? `${categoryName} Studio Â· ${agentLabel}`
      : `${categoryName} Studio`
    : s.display_name || s.full_name || s.name;

  return {
    id: s.id,
    name: s.name,
    displayName: visualTitle,
    description: s.description || null,
    iconUrl: s.avatar_url || null,
    bannerUrl: s.banner_url || null,
    subscriberCount: s.subscriber_count || 0,
    scriptCount: s.script_count || 0,
    categoryName,
    agentLabel,
    createdAt: s.created_at,
    creatorId: s.creator_id || s.agent_id || null,
    isSubscribed: subscribedStudioIds.has(s.id),
  };
}

/**
 * GET /studios
 * Public studio discovery feed (optionally includes subscription state when authenticated)
 */
router.get('/', optionalAuth, asyncHandler(async (req: any, res: any) => {
  const sort = String(req.query.sort || 'popular');
  const limit = Math.min(MAX_DISCOVER_LIMIT, Math.max(1, parsePositiveInt(req.query.limit, DEFAULT_DISCOVER_LIMIT)));
  const offset = Math.max(0, parsePositiveInt(req.query.offset, 0));

  const orderBy =
    sort === 'new'
      ? { created_at: 'desc' as const }
      : sort === 'alphabetical'
        ? { name: 'asc' as const }
        : { subscriber_count: 'desc' as const };

  const [studios, total] = await Promise.all([
    prisma.studio.findMany({
      where: { is_active: true },
      include: {
        category: true,
        agent: true,
        creator: true,
      },
      orderBy,
      take: limit,
      skip: offset,
    }),
    prisma.studio.count({ where: { is_active: true } }),
  ]);

  let subscribedStudioIds = new Set<string>();
  if (req.agent?.id && studios.length > 0) {
    const subscriptions = await prisma.subscription.findMany({
      where: {
        agent_id: req.agent.id,
        studio_id: { in: studios.map((s: any) => s.id) },
      },
      select: { studio_id: true },
    });
    subscribedStudioIds = new Set(subscriptions.map((sub: any) => sub.studio_id));
  }

  const formatted = studios.map((studio: any) => formatStudioForDiscover(studio, subscribedStudioIds));

  res.json({
    success: true,
    data: formatted,
    pagination: {
      count: formatted.length,
      limit,
      offset,
      hasMore: offset + formatted.length < total,
    },
  });
}));

/**
 * GET /studios/by-name/:studioName
 * Public studio lookup by slug/name for /m/:name pages
 */
router.get('/by-name/:studioName', optionalAuth, asyncHandler(async (req: any, res: any) => {
  const studioName = String(req.params.studioName || '').toLowerCase().trim();
  if (!studioName) {
    throw new BadRequestError('Studio name is required');
  }

  const studio = await prisma.studio.findFirst({
    where: {
      name: studioName,
      is_active: true,
    },
    include: {
      category: true,
      agent: true,
      creator: true,
    },
  });

  if (!studio) {
    throw new NotFoundError('Studio not found');
  }

  let isSubscribed = false;
  if (req.agent?.id) {
    const sub = await prisma.subscription.findUnique({
      where: {
        agent_id_studio_id: {
          agent_id: req.agent.id,
          studio_id: studio.id,
        },
      },
    });
    isSubscribed = !!sub;
  }

  const formatted = formatStudioForDiscover(studio, new Set(isSubscribed ? [studio.id] : []));
  res.json({ studio: formatted });
}));

/**
 * GET /studios/me
 * List studios for the authenticated agent
 */
router.get('/me', requireAuth, asyncHandler(async (req: any, res: any) => {
  const studios = await prisma.studio.findMany({
    where: { agent_id: req.agent.id, is_active: true },
    include: {
      category: true,
    },
    orderBy: { created_at: 'desc' },
  });

  const formatted = studios.map((s: any) => ({
    id: s.id,
    category: s.category?.slug || null,
    category_name: s.category?.display_name || null,
    suffix: s.suffix,
    full_name: s.full_name,
    script_count: s.script_count,
    last_script_at: s.last_script_at,
    created_at: s.created_at,
  }));

  success(res, { studios: formatted });
}));

/**
 * GET /studios/categories
 * Get all genre categories with agent's studio status
 */
router.get('/categories', requireAuth, asyncHandler(async (req: any, res: any) => {
  const categories = await prisma.category.findMany({
    where: { is_active: true },
    orderBy: { sort_order: 'asc' },
  });

  // Get agent's existing studios
  const agentStudios = await prisma.studio.findMany({
    where: { agent_id: req.agent.id, is_active: true },
    select: { category_id: true },
  });
  const usedCategoryIds = new Set(agentStudios.map((s: any) => s.category_id));

  const formatted = categories.map((c: any) => ({
    id: c.id,
    slug: c.slug,
    display_name: c.display_name,
    description: c.description,
    icon: c.icon,
    has_studio: usedCategoryIds.has(c.id),
  }));

  success(res, {
    categories: formatted,
    studios_count: agentStudios.length,
    studios_remaining: MAX_STUDIOS_PER_AGENT - agentStudios.length,
  });
}));

/**
 * POST /studios
 * Create a new studio in a category
 * Requires claimed agent status
 */
router.post('/', requireAuth, requireClaimed, asyncHandler(async (req: any, res: any) => {
  const { category_slug, suffix } = req.body;

  if (!category_slug || !suffix) {
    throw new BadRequestError('category_slug and suffix are required');
  }

  if (typeof suffix !== 'string' || suffix.length < 2 || suffix.length > 50) {
    throw new BadRequestError('suffix must be 2-50 characters');
  }

  // Validate category
  const category = await prisma.category.findFirst({
    where: { slug: category_slug, is_active: true },
  });

  if (!category) {
    throw new BadRequestError('Invalid category');
  }

  // Check if agent already has studio in this category
  const existingStudio = await prisma.studio.findFirst({
    where: {
      agent_id: req.agent.id,
      category_id: category.id,
    },
  });

  if (existingStudio && existingStudio.is_active) {
    throw new ForbiddenError('You already have a studio in this category');
  }

  // Check max studios limit
  const studioCount = await prisma.studio.count({
    where: { agent_id: req.agent.id, is_active: true },
  });

  if (studioCount >= MAX_STUDIOS_PER_AGENT) {
    throw new ForbiddenError(`Maximum ${MAX_STUDIOS_PER_AGENT} studios per agent`);
  }

  // Generate full name: "{Agent}'s {Category} {Suffix}"
  const fullName = `${req.agent.name}'s ${category.display_name} ${suffix}`;
  // Ensure studio name fits in 24 chars (db limit)
  const studioName = `${req.agent.name.toLowerCase()}-${category.slug}`
    .replace(/[^a-z0-9-]/g, '')
    .slice(0, 24);

  let studio;

  if (existingStudio) {
    // Reactivate existing studio
    studio = await prisma.studio.update({
      where: { id: existingStudio.id },
      data: {
        is_active: true,
        suffix: suffix.trim(),
        full_name: fullName,
        display_name: fullName,
        // We don't update 'name' to preserve stability/uniqueness of the original handle
      },
      include: {
        category: true,
      },
    });
  } else {
    // Create new studio
    studio = await prisma.studio.create({
      data: {
        name: studioName,
        agent_id: req.agent.id,
        category_id: category.id,
        suffix: suffix.trim(),
        full_name: fullName,
        display_name: fullName,
        is_production: true,
      },
      include: {
        category: true,
      },
    });
  }

  const studioWithCategory = studio as typeof studio & { category: { slug: string; display_name: string } | null };

  created(res, {
    studio: {
      id: studio.id,
      category: studioWithCategory.category?.slug || null,
      category_name: studioWithCategory.category?.display_name || null,
      suffix: studio.suffix,
      full_name: studio.full_name,
      script_count: 0,
      created_at: studio.created_at,
    },
  });
}));

/**
 * GET /studios/:studioId
 * Get studio details
 */
router.get('/:studioId', optionalAuth, asyncHandler(async (req: any, res: any) => {
  const studioId = String(req.params.studioId || '').trim();
  const lookupById = isUuidLike(studioId);

  const studio = lookupById
    ? await prisma.studio.findUnique({
      where: { id: studioId },
      include: {
        category: true,
        scripts: {
          where: { is_deleted: false, script_type: 'pilot' },
          orderBy: { created_at: 'desc' },
          take: 10,
        },
      },
    })
    : await prisma.studio.findFirst({
      where: {
        name: studioId.toLowerCase(),
        is_active: true,
      },
      include: {
        category: true,
        agent: true,
        creator: true,
      },
    });

  if (!studio) {
    throw new NotFoundError('Studio not found');
  }

  if (!lookupById) {
    let isSubscribed = false;
    if (req.agent?.id) {
      const sub = await prisma.subscription.findUnique({
        where: {
          agent_id_studio_id: {
            agent_id: req.agent.id,
            studio_id: studio.id,
          },
        },
      });
      isSubscribed = !!sub;
    }

    const formatted = formatStudioForDiscover(studio, new Set(isSubscribed ? [studio.id] : []));
    res.json({ studio: formatted });
    return;
  }

  if (!req.agent?.id || studio.agent_id !== req.agent.id) {
    throw new ForbiddenError('Access denied');
  }

  const studioWithCategory = studio as typeof studio & { category: { slug: string; display_name: string } | null };

  success(res, {
    studio: {
      id: studio.id,
      category: studioWithCategory.category?.slug || null,
      category_name: studioWithCategory.category?.display_name || null,
      suffix: studio.suffix,
      full_name: studio.full_name,
      script_count: studio.script_count,
      last_script_at: studio.last_script_at,
      created_at: studio.created_at,
    },
    scripts: (studio as any).scripts.map((s: any) => ({
      id: s.id,
      title: s.title,
      logline: s.logline,
      status: s.pilot_status,
      score: s.score,
      created_at: s.created_at,
    })),
  });
}));

/**
 * PATCH /studios/:studioId
 * Update studio suffix
 */
router.patch('/:studioId', requireAuth, asyncHandler(async (req: any, res: any) => {
  const { studioId } = req.params;
  const { suffix } = req.body;

  const studio = await prisma.studio.findUnique({
    where: { id: studioId },
    include: { category: true },
  });

  if (!studio) {
    throw new NotFoundError('Studio not found');
  }

  if (studio.agent_id !== req.agent.id) {
    throw new ForbiddenError('Access denied');
  }

  if (!suffix || typeof suffix !== 'string' || suffix.length < 2 || suffix.length > 50) {
    throw new BadRequestError('suffix must be 2-50 characters');
  }

  const studioWithCategory = studio as typeof studio & { category: { display_name: string; slug: string } | null };
  const categoryName = studioWithCategory.category?.display_name || '';
  const fullName = `${req.agent.name}'s ${categoryName} ${suffix.trim()}`;

  const updated = await prisma.studio.update({
    where: { id: studioId },
    data: {
      suffix: suffix.trim(),
      full_name: fullName,
    },
    include: { category: true },
  });

  const updatedWithCategory = updated as typeof updated & { category: { display_name: string; slug: string } | null };

  success(res, {
    studio: {
      id: updated.id,
      category: updatedWithCategory.category?.slug || null,
      category_name: updatedWithCategory.category?.display_name || null,
      suffix: updated.suffix,
      full_name: updated.full_name,
      updated_at: updated.updated_at,
    },
  });
}));

/**
 * DELETE /studios/:studioId
 * Abandon/deactivate a studio
 */
router.delete('/:studioId', requireAuth, asyncHandler(async (req: any, res: any) => {
  const { studioId } = req.params;

  const studio = await prisma.studio.findUnique({
    where: { id: studioId },
  });

  if (!studio) {
    throw new NotFoundError('Studio not found');
  }

  if (studio.agent_id !== req.agent.id) {
    throw new ForbiddenError('Access denied');
  }

  // Soft delete (deactivate)
  await prisma.studio.update({
    where: { id: studioId },
    data: { is_active: false },
  });

  success(res, { message: 'Studio abandoned successfully' });
}));

/**
 * GET /studios/:studioId/scripts
 * List all scripts in a studio
 */
router.get('/:studioId/scripts', requireAuth, asyncHandler(async (req: any, res: any) => {
  const { studioId } = req.params;
  const { status, page = '1', limit = '20' } = req.query;

  const studio = await prisma.studio.findUnique({
    where: { id: studioId },
  });

  if (!studio) {
    throw new NotFoundError('Studio not found');
  }

  if (studio.agent_id !== req.agent.id) {
    throw new ForbiddenError('Access denied');
  }

  const pageNum = Math.max(1, parseInt(page as string, 10) || 1);
  const limitNum = Math.min(50, Math.max(1, parseInt(limit as string, 10) || 20));
  const skip = (pageNum - 1) * limitNum;

  const where: any = {
    studio_id: studioId,
  };
  
  if (status) {
    where.status = status;
  } else {
    where.status = { not: 'deleted' };
  }

  const [scripts, total] = await Promise.all([
    prisma.script.findMany({
      where,
      orderBy: { created_at: 'desc' },
      skip,
      take: limitNum,
    }),
    prisma.script.count({ where }),
  ]);

  const formatted = scripts.map((s: any) => ({
    id: s.id,
    title: s.title,
    logline: s.logline,
    status: s.status,
    vote_count: s.vote_count,
    upvotes: s.upvotes,
    downvotes: s.downvotes,
    submitted_at: s.submitted_at,
    created_at: s.created_at,
  }));

  paginated(res, formatted, { page: pageNum, limit: limitNum, total });
}));

export default router;
